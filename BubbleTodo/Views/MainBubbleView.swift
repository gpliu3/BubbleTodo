//
//  MainBubbleView.swift
//  BubbleTodo
//

import SwiftUI
import SwiftData
import Combine

struct MainBubbleView: View {
    @Environment(\.modelContext) private var modelContext
    @Query(filter: #Predicate<TaskItem> { !$0.isCompleted },
           sort: \TaskItem.createdAt)
    private var allTasks: [TaskItem]

    @State private var showingAddSheet = false
    @State private var editingTask: TaskItem?
    @State private var currentTime = Date()
    @ObservedObject private var localizationManager = LocalizationManager.shared

    // Undo state
    @State private var recentlyCompletedTask: TaskItem?
    @State private var createdRecurringTask: TaskItem?
    @State private var showUndoToast = false
    @State private var undoTimer: Timer?

    // Timer for updating time-based positioning
    let timeUpdateTimer = Timer.publish(every: 60, on: .main, in: .common).autoconnect()

    // Filter tasks to only show those due today, overdue, or without due date
    private var todayTasks: [TaskItem] {
        allTasks.filter { $0.shouldShowToday }
    }

    // Sort tasks by priority/urgency (highest sortScore first = top)
    private var sortedTasks: [TaskItem] {
        todayTasks.sorted { $0.sortScore > $1.sortScore }
    }

    // Day progress: 0.0 at 6 AM, 1.0 at 10 PM
    private var dayProgress: Double {
        let calendar = Calendar.current
        let hour = calendar.component(.hour, from: currentTime)
        let minute = calendar.component(.minute, from: currentTime)

        let currentMinutes = Double(hour * 60 + minute)
        let startMinutes: Double = 6 * 60  // 6 AM
        let endMinutes: Double = 22 * 60   // 10 PM

        let progress = (currentMinutes - startMinutes) / (endMinutes - startMinutes)
        return min(max(progress, 0), 1)
    }

    var body: some View {
        ZStack {
            // Background gradient - changes with time of day
            LinearGradient(
                gradient: Gradient(colors: [
                    Color(.systemBackground),
                    dayProgress > 0.7 ? Color.orange.opacity(0.1) : Color(.systemGray6)
                ]),
                startPoint: .top,
                endPoint: .bottom
            )
            .ignoresSafeArea()

            if todayTasks.isEmpty {
                emptyStateView
            } else {
                bubbleGridView
            }

            // Floating add button
            VStack {
                Spacer()
                HStack {
                    Spacer()
                    addButton
                }
            }
            .padding()
            .padding(.bottom, showUndoToast ? 60 : 0)

            // Undo toast
            if showUndoToast, let completedTask = recentlyCompletedTask {
                VStack {
                    Spacer()
                    UndoToastView(
                        taskTitle: completedTask.title,
                        onUndo: {
                            undoCompletion()
                        }
                    )
                    .padding(.horizontal)
                    .padding(.bottom, 16)
                    .transition(.move(edge: .bottom).combined(with: .opacity))
                }
            }
        }
        .navigationTitle(L("main.title"))
        .navigationBarTitleDisplayMode(.large)
        .sheet(isPresented: $showingAddSheet) {
            AddTaskSheet()
        }
        .sheet(item: $editingTask) { task in
            EditTaskSheet(task: task)
        }
        .onReceive(timeUpdateTimer) { _ in
            currentTime = Date()
        }
    }

    private var emptyStateView: some View {
        VStack(spacing: 12) {
            Image(systemName: "bubble.left.and.bubble.right")
                .font(.system(size: 48))
                .foregroundColor(.secondary)

            Text(L("main.empty.title"))
                .font(.title3)
                .foregroundColor(.secondary)

            Text(L("main.empty.subtitle"))
                .font(.callout)
                .foregroundColor(.secondary)
        }
    }

    private var bubbleGridView: some View {
        GeometryReader { geometry in
            ScrollView {
                BubbleLayoutView(
                    tasks: sortedTasks,
                    containerWidth: geometry.size.width,
                    containerHeight: geometry.size.height,
                    dayProgress: dayProgress,
                    onTap: { task in
                        completeTask(task)
                    },
                    onLongPress: { task in
                        editingTask = task
                    }
                )
                .padding(.bottom, 100) // Space for add button
            }
        }
    }

    private var addButton: some View {
        Button(action: {
            showingAddSheet = true
        }) {
            Image(systemName: "plus")
                .font(.title3.weight(.semibold))
                .foregroundColor(.white)
                .frame(width: 56, height: 56)
                .background(
                    Circle()
                        .fill(
                            LinearGradient(
                                gradient: Gradient(colors: [.blue, .purple]),
                                startPoint: .topLeading,
                                endPoint: .bottomTrailing
                            )
                        )
                )
                .shadow(color: .blue.opacity(0.3), radius: 6, x: 0, y: 3)
        }
        .accessibilityLabel(L("accessibility.add.task"))
    }

    private func completeTask(_ task: TaskItem) {
        // Cancel any existing undo timer
        undoTimer?.invalidate()

        withAnimation {
            task.markComplete()

            // Store for undo
            recentlyCompletedTask = task
            createdRecurringTask = nil

            // If recurring, create the next instance
            if let nextTask = task.createNextRecurringTask() {
                modelContext.insert(nextTask)
                createdRecurringTask = nextTask
            }

            // Show undo toast
            showUndoToast = true
        }

        // Start 3 second timer
        undoTimer = Timer.scheduledTimer(withTimeInterval: 3.0, repeats: false) { _ in
            withAnimation {
                showUndoToast = false
                recentlyCompletedTask = nil
                createdRecurringTask = nil
            }
        }
    }

    private func undoCompletion() {
        undoTimer?.invalidate()

        withAnimation {
            // Undo the task completion
            recentlyCompletedTask?.undoComplete()

            // Remove the recurring task if one was created
            if let recurringTask = createdRecurringTask {
                modelContext.delete(recurringTask)
            }

            showUndoToast = false
            recentlyCompletedTask = nil
            createdRecurringTask = nil
        }
    }
}

// MARK: - Day Progress Indicator

struct DayProgressIndicator: View {
    let progress: Double

    var body: some View {
        HStack(spacing: 4) {
            Image(systemName: progress < 0.5 ? "sun.rise.fill" : "sun.max.fill")
                .foregroundColor(progress > 0.7 ? .orange : .yellow)
                .font(.caption)

            Text("\(Int(progress * 100))%")
                .font(.caption2.monospacedDigit())
                .foregroundColor(.secondary)
        }
    }
}

// MARK: - Undo Toast View

struct UndoToastView: View {
    let taskTitle: String
    let onUndo: () -> Void

    var body: some View {
        HStack(spacing: 10) {
            Image(systemName: "checkmark.circle.fill")
                .font(.body)
                .foregroundColor(.green)

            Text(String(format: L("main.completed"), taskTitle))
                .font(.callout)
                .lineLimit(1)

            Spacer()

            Button(action: onUndo) {
                Text(L("main.undo"))
                    .font(.callout.weight(.semibold))
                    .foregroundColor(.blue)
            }
        }
        .padding(.horizontal, 14)
        .padding(.vertical, 10)
        .background(
            RoundedRectangle(cornerRadius: 10)
                .fill(Color(.systemBackground))
                .shadow(color: .black.opacity(0.12), radius: 6, x: 0, y: 3)
        )
    }
}

// MARK: - Bubble Layout View

struct BubbleLayoutView: View {
    let tasks: [TaskItem]
    let containerWidth: CGFloat
    let containerHeight: CGFloat
    let dayProgress: Double
    let onTap: (TaskItem) -> Void
    let onLongPress: (TaskItem) -> Void

    // Morning offset: bubbles start lower, rise throughout the day
    // At 0% progress (morning): offset = maxOffset (bubbles at bottom)
    // At 100% progress (evening): offset = 0 (bubbles at top)
    private var verticalOffset: CGFloat {
        let maxOffset: CGFloat = max(containerHeight * 0.4, 200)
        return maxOffset * (1 - dayProgress)
    }

    // Cache bubble diameters to avoid repeated calculations
    private var cachedDiameters: [UUID: CGFloat] {
        var cache: [UUID: CGFloat] = [:]
        for task in tasks {
            cache[task.id] = Self.bubbleDiameter(for: task)
        }
        return cache
    }

    // Pre-calculate layout once per render
    private var layoutData: (positions: [CGPoint], totalHeight: CGFloat) {
        calculateLayout()
    }

    var body: some View {
        let layout = layoutData

        ZStack(alignment: .top) {
            ForEach(Array(tasks.enumerated()), id: \.element.id) { index, task in
                if index < layout.positions.count {
                    BubbleView(
                        task: task,
                        onTap: { onTap(task) },
                        onLongPress: { onLongPress(task) }
                    )
                    .position(layout.positions[index])
                }
            }
        }
        .frame(width: containerWidth, height: layout.totalHeight)
        .offset(y: verticalOffset)
        .animation(.easeInOut(duration: 1.0), value: dayProgress)
    }

    // Static method to calculate diameter - no self reference needed
    private static func bubbleDiameter(for task: TaskItem) -> CGFloat {
        let baseSize: CGFloat = 62
        let scaleFactor: CGFloat = 9
        let size = baseSize + CGFloat(task.bubbleSize) * scaleFactor
        return min(max(size, 65), 165)
    }

    // Combined layout calculation - positions and height in one pass
    private func calculateLayout() -> (positions: [CGPoint], totalHeight: CGFloat) {
        var positions: [CGPoint] = []
        var currentY: CGFloat = 20
        var currentRowBubbles: [(id: UUID, diameter: CGFloat)] = []
        var currentRowWidth: CGFloat = 0
        let padding: CGFloat = 16
        let availableWidth = containerWidth - (padding * 2)
        let diameters = cachedDiameters

        for task in tasks {
            let diameter = diameters[task.id] ?? Self.bubbleDiameter(for: task)
            let bubbleWidth = diameter + 8

            // Check if bubble fits in current row
            if currentRowWidth + bubbleWidth > availableWidth && !currentRowBubbles.isEmpty {
                // Finalize current row - center it
                let rowHeight = currentRowBubbles.map { $0.diameter }.max() ?? 0
                let totalRowWidth = currentRowBubbles.reduce(0) { $0 + $1.diameter + 8 }
                var xOffset = (containerWidth - totalRowWidth) / 2

                for bubble in currentRowBubbles {
                    positions.append(CGPoint(
                        x: xOffset + bubble.diameter / 2,
                        y: currentY + rowHeight / 2
                    ))
                    xOffset += bubble.diameter + 8
                }

                // Start new row
                currentY += rowHeight + 16
                currentRowBubbles = []
                currentRowWidth = 0
            }

            currentRowBubbles.append((id: task.id, diameter: diameter))
            currentRowWidth += bubbleWidth
        }

        // Finalize last row
        if !currentRowBubbles.isEmpty {
            let rowHeight = currentRowBubbles.map { $0.diameter }.max() ?? 0
            let totalRowWidth = currentRowBubbles.reduce(0) { $0 + $1.diameter + 8 }
            var xOffset = (containerWidth - totalRowWidth) / 2

            for bubble in currentRowBubbles {
                positions.append(CGPoint(
                    x: xOffset + bubble.diameter / 2,
                    y: currentY + rowHeight / 2
                ))
                xOffset += bubble.diameter + 8
            }
            currentY += rowHeight
        }

        return (positions, currentY + 100)
    }
}

#Preview {
    NavigationStack {
        MainBubbleView()
    }
    .modelContainer(for: TaskItem.self, inMemory: true)
}
